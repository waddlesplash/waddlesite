<?php
/**
 * mustache.php d99be3444e
 * see: https://github.com/bobthecow/mustache.php/commit/d99be3444e5b2f0fb605941d7e692d3b5159360c
 * Copyright (c) 2012 Justin Hileman
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

interface Mustache_Loader{public function load($name);}class Mustache_Loader_StringLoader implements Mustache_Loader{public function load($name){return $name;}}class Mustache_Compiler{private $sections;private $source;private $indentNextLine;private $customEscape;private $charset;public function compile($source,array $tree,$name,$customEscape=false,$charset='UTF-8'){$this->sections=array();$this->source=$source;$this->indentNextLine=true;$this->customEscape=$customEscape;$this->charset=$charset;return $this->writeCode($tree,$name);}private function walk(array $tree,$level=0){$code='';$level++;foreach($tree as $node){switch($node[Mustache_Tokenizer::TYPE]){case  Mustache_Tokenizer::T_SECTION:$code.=$this->section($node[Mustache_Tokenizer::NODES],$node[Mustache_Tokenizer::NAME],$node[Mustache_Tokenizer::INDEX],$node[Mustache_Tokenizer::END],$node[Mustache_Tokenizer::OTAG],$node[Mustache_Tokenizer::CTAG],$level);break;case  Mustache_Tokenizer::T_INVERTED:$code.=$this->invertedSection($node[Mustache_Tokenizer::NODES],$node[Mustache_Tokenizer::NAME],$level);break;case  Mustache_Tokenizer::T_PARTIAL:case  Mustache_Tokenizer::T_PARTIAL_2:$code.=$this->partial($node[Mustache_Tokenizer::NAME],isset($node[Mustache_Tokenizer::INDENT])?$node[Mustache_Tokenizer::INDENT]:'',$level);break;case  Mustache_Tokenizer::T_UNESCAPED:case  Mustache_Tokenizer::T_UNESCAPED_2:$code.=$this->variable($node[Mustache_Tokenizer::NAME],false,$level);break;case  Mustache_Tokenizer::T_COMMENT:break;case  Mustache_Tokenizer::T_ESCAPED:$code.=$this->variable($node[Mustache_Tokenizer::NAME],true,$level);break;case  Mustache_Tokenizer::T_TEXT:$code.=$this->text($node[Mustache_Tokenizer::VALUE],$level);break;default:throw new InvalidArgumentException('Unknown node type: '.json_encode($node));}}return $code;}const KLASS='<?php

class %s extends Mustache_Template
{
public function renderInternal(Mustache_Context $context, $indent = \'\', $escape = false)
{
$buffer = \'\';
%s

if ($escape) {
return %s;
} else {
return $buffer;
}
}
%s
}';private function writeCode($tree,$name){$code=$this->walk($tree);$sections=implode("\n",$this->sections);return sprintf($this->prepare(self::KLASS,0,false),$name,$code,$this->getEscape('$buffer'),$sections);}const SECTION_CALL='
// %s section
$buffer .= $this->section%s($context, $indent, $context->%s(%s));
';const SECTION='
private function section%s(Mustache_Context $context, $indent, $value) {
$buffer = \'\';
if (!is_string($value) && is_callable($value)) {
$source = %s;
$buffer .= $this->mustache
->loadLambda((string) call_user_func($value, $source)%s)
->renderInternal($context, $indent);
} elseif (!empty($value)) {
$values = $this->isIterable($value) ? $value : array($value);
foreach ($values as $value) {
$context->push($value);%s
$context->pop();
}
}

return $buffer;
}';private function section($nodes,$id,$start,$end,$otag,$ctag,$level){$method=$this->getFindMethod($id);$id=var_export($id,true);$source=var_export(substr($this->source,$start,$end-$start),true);if($otag!=='{{'||$ctag!=='}}'){$delims=', '.var_export(sprintf('{{= %s %s =}}',$otag,$ctag),true);}else{$delims='';}$key=ucfirst(md5($delims."\n".$source));if(!isset($this->sections[$key])){$this->sections[$key]=sprintf($this->prepare(self::SECTION),$key,$source,$delims,$this->walk($nodes,2));}return sprintf($this->prepare(self::SECTION_CALL,$level),$id,$key,$method,$id);}const INVERTED_SECTION='
// %s inverted section
$value = $context->%s(%s);
if (empty($value)) {
%s
}';private function invertedSection($nodes,$id,$level){$method=$this->getFindMethod($id);$id=var_export($id,true);return sprintf($this->prepare(self::INVERTED_SECTION,$level),$id,$method,$id,$this->walk($nodes,$level));}const PARTIAL='
if ($partial = $this->mustache->loadPartial(%s)) {
$buffer .= $partial->renderInternal($context, %s);
}
';private function partial($id,$indent,$level){return sprintf($this->prepare(self::PARTIAL,$level),var_export($id,true),var_export($indent,true));}const VARIABLE='
$value = $context->%s(%s);
if (!is_string($value) && is_callable($value)) {
$value = $this->mustache
->loadLambda((string) call_user_func($value))
->renderInternal($context, $indent);
}
$buffer .= %s%s;
';private function variable($id,$escape,$level){$method=$this->getFindMethod($id);$id=($method!=='last')?var_export($id,true):'';$value=$escape?$this->getEscape():'$value';return sprintf($this->prepare(self::VARIABLE,$level),$method,$id,$this->flushIndent(),$value);}const LINE='$buffer .= "\n";';const TEXT='$buffer .= %s%s;';private function text($text,$level){if($text==="\n"){$this->indentNextLine=true;return $this->prepare(self::LINE,$level);}else{return sprintf($this->prepare(self::TEXT,$level),$this->flushIndent(),var_export($text,true));}}private function prepare($text,$bonus=0,$prependNewline=true){$text=($prependNewline?"\n":'').trim($text);if($prependNewline){$bonus++;}return preg_replace("/\n( {8})?/","\n".str_repeat(" ",$bonus*4),$text);}const DEFAULT_ESCAPE='htmlspecialchars(%s, ENT_COMPAT, %s)';const CUSTOM_ESCAPE='call_user_func($this->mustache->getEscape(), %s)';private function getEscape($value='$value'){if($this->customEscape){return sprintf(self::CUSTOM_ESCAPE,$value);}else{return sprintf(self::DEFAULT_ESCAPE,$value,var_export($this->charset,true));}}private function getFindMethod($id){if($id==='.'){return 'last';}elseif(strpos($id,'.')===false){return 'find';}else{return 'findDot';}}const LINE_INDENT='$indent . ';private function flushIndent(){if($this->indentNextLine){$this->indentNextLine=false;return self::LINE_INDENT;}else{return'';}}}class Mustache_Context{private $stack=array();public function __construct($context=null){if($context!==null){$this->stack=array($context);}}public function push($value){array_push($this->stack,$value);}public function pop(){return array_pop($this->stack);}public function last(){return end($this->stack);}public function find($id){return $this->findVariableInStack($id,$this->stack);}public function findDot($id){$chunks=explode('.',$id);$first=array_shift($chunks);$value=$this->findVariableInStack($first,$this->stack);foreach($chunks as $chunk){if($value===''){return $value;}$value=$this->findVariableInStack($chunk,array($value));}return $value;}private function findVariableInStack($id,array $stack){for($i=count($stack)-1;$i>=0;$i--){if(is_object($stack[$i])){if(method_exists($stack[$i],$id)){return $stack[$i]->$id();}elseif(isset($stack[$i]->$id)){return $stack[$i]->$id;}}elseif(is_array($stack[$i])&&array_key_exists($id,$stack[$i])){return $stack[$i][$id];}}return'';}}class Mustache_Engine{const VERSION='2.0.2';const SPEC_VERSION='1.1.2';private $templates=array();private $templateClassPrefix='__Mustache_';private $cache=null;private $loader;private $partialsLoader;private $helpers;private $escape;private $charset='UTF-8';public function __construct(array $options=array()){if(isset($options['template_class_prefix'])){$this->templateClassPrefix=$options['template_class_prefix'];}if(isset($options['cache'])){$this->cache=$options['cache'];}if(isset($options['loader'])){$this->setLoader($options['loader']);}if(isset($options['partials_loader'])){$this->setPartialsLoader($options['partials_loader']);}if(isset($options['partials'])){$this->setPartials($options['partials']);}if(isset($options['helpers'])){$this->setHelpers($options['helpers']);}if(isset($options['escape'])){if(!is_callable($options['escape'])){throw new InvalidArgumentException('Mustache Constructor "escape" option must be callable');}$this->escape=$options['escape'];}if(isset($options['charset'])){$this->charset=$options['charset'];}}public function render($template,$data){return $this->loadTemplate($template)->render($data);}public function getEscape(){return $this->escape;}public function getCharset(){return $this->charset;}public function setLoader(Mustache_Loader $loader){$this->loader=$loader;}public function getLoader(){if(!isset($this->loader)){$this->loader=new Mustache_Loader_StringLoader;}return $this->loader;}public function setPartialsLoader(Mustache_Loader $partialsLoader){$this->partialsLoader=$partialsLoader;}public function getPartialsLoader(){if(!isset($this->partialsLoader)){$this->partialsLoader=new Mustache_Loader_ArrayLoader;}return $this->partialsLoader;}public function setPartials(array $partials=array()){$loader=$this->getPartialsLoader();if(!$loader instanceof Mustache_Loader_MutableLoader){throw new RuntimeException('Unable to set partials on an immutable Mustache Loader instance');}$loader->setTemplates($partials);}public function setHelpers($helpers){if(!is_array($helpers)&&!$helpers instanceof Traversable){throw new InvalidArgumentException('setHelpers expects an array of helpers');}$this->getHelpers()->clear();foreach($helpers as $name=>$helper){$this->addHelper($name,$helper);}}public function getHelpers(){if(!isset($this->helpers)){$this->helpers=new Mustache_HelperCollection;}return $this->helpers;}public function addHelper($name,$helper){$this->getHelpers()->add($name,$helper);}public function getHelper($name){return $this->getHelpers()->get($name);}public function hasHelper($name){return $this->getHelpers()->has($name);}public function removeHelper($name){$this->getHelpers()->remove($name);}public function setTokenizer(Mustache_Tokenizer $tokenizer){$this->tokenizer=$tokenizer;}public function getTokenizer(){if(!isset($this->tokenizer)){$this->tokenizer=new Mustache_Tokenizer;}return $this->tokenizer;}public function setParser(Mustache_Parser $parser){$this->parser=$parser;}public function getParser(){if(!isset($this->parser)){$this->parser=new Mustache_Parser;}return $this->parser;}public function setCompiler(Mustache_Compiler $compiler){$this->compiler=$compiler;}public function getCompiler(){if(!isset($this->compiler)){$this->compiler=new Mustache_Compiler;}return $this->compiler;}public function getTemplateClassName($source){return $this->templateClassPrefix.md5(sprintf('version:%s,escape:%s,charset:%s,source:%s',self::VERSION,isset($this->escape)?'custom':'default',$this->charset,$source));}public function loadTemplate($name){return $this->loadSource($this->getLoader()->load($name));}public function loadPartial($name){try{return $this->loadSource($this->getPartialsLoader()->load($name));}catch(InvalidArgumentException $e){}}public function loadLambda($source,$delims=null){if($delims!==null){$source=$delims."\n".$source;}return $this->loadSource($source);}private function loadSource($source){$className=$this->getTemplateClassName($source);if(!isset($this->templates[$className])){if(!class_exists($className,false)){if($fileName=$this->getCacheFilename($source)){if(!is_file($fileName)){$this->writeCacheFile($fileName,$this->compile($source));}require_once $fileName;}else{eval('?>'.$this->compile($source));}}$this->templates[$className]=new $className($this);}return $this->templates[$className];}private function tokenize($source){return $this->getTokenizer()->scan($source);}private function parse($source){return $this->getParser()->parse($this->tokenize($source));}private function compile($source){$tree=$this->parse($source);$name=$this->getTemplateClassName($source);return $this->getCompiler()->compile($source,$tree,$name,isset($this->escape),$this->charset);}private function getCacheFilename($source){if($this->cache){return sprintf('%s/%s.php',$this->cache,$this->getTemplateClassName($source));}}private function writeCacheFile($fileName,$source){if(!is_dir(dirname($fileName))){mkdir(dirname($fileName),0777,true);}$tempFile=tempnam(dirname($fileName),basename($fileName));if(false!==@file_put_contents($tempFile,$source)){if(@rename($tempFile,$fileName)){chmod($fileName,0644);return;}}throw new RuntimeException(sprintf('Failed to write cache file "%s".',$fileName));}}class Mustache_HelperCollection{private $helpers=array();public function __construct($helpers=null){if($helpers!==null){if(!is_array($helpers)&&!$helpers instanceof Traversable){throw new InvalidArgumentException('HelperCollection constructor expects an array of helpers');}foreach($helpers as $name=>$helper){$this->add($name,$helper);}}}public function __set($name,$helper){$this->add($name,$helper);}public function add($name,$helper){$this->helpers[$name]=$helper;}public function __get($name){return $this->get($name);}public function get($name){if(!$this->has($name)){throw new InvalidArgumentException('Unknown helper: '.$name);}return $this->helpers[$name];}public function __isset($name){return $this->has($name);}public function has($name){return array_key_exists($name,$this->helpers);}public function __unset($name){$this->remove($name);}public function remove($name){if(!$this->has($name)){throw new InvalidArgumentException('Unknown helper: '.$name);}unset($this->helpers[$name]);}public function clear(){$this->helpers=array();}public function isEmpty(){return empty($this->helpers);}}class Mustache_Parser{public function parse(array $tokens=array()){return $this->buildTree(new ArrayIterator($tokens));}private function buildTree(ArrayIterator $tokens,array $parent=null){$nodes=array();do{$token=$tokens->current();$tokens->next();if($token===null){continue;}else{switch($token[Mustache_Tokenizer::TYPE]){case  Mustache_Tokenizer::T_SECTION:case  Mustache_Tokenizer::T_INVERTED:$nodes[]=$this->buildTree($tokens,$token);break;case  Mustache_Tokenizer::T_END_SECTION:if(!isset($parent)){throw new LogicException('Unexpected closing tag: /'.$token[Mustache_Tokenizer::NAME]);}if($token[Mustache_Tokenizer::NAME]!==$parent[Mustache_Tokenizer::NAME]){throw new LogicException('Nesting error: '.$parent[Mustache_Tokenizer::NAME].' vs. '.$token[Mustache_Tokenizer::NAME]);}$parent[Mustache_Tokenizer::END]=$token[Mustache_Tokenizer::INDEX];$parent[Mustache_Tokenizer::NODES]=$nodes;return $parent;break;default:$nodes[]=$token;break;}}}while($tokens->valid());if(isset($parent)){throw new LogicException('Missing closing tag: '.$parent[Mustache_Tokenizer::NAME]);}return $nodes;}}abstract class Mustache_Template{protected $mustache;public function __construct(Mustache_Engine $mustache){$this->mustache=$mustache;}public function __invoke($context=array()){return $this->render($context);}public function render($context=array()){return $this->renderInternal($this->prepareContextStack($context));}abstract public function renderInternal(Mustache_Context $context,$indent='',$escape=false);protected function isIterable($value){if(is_object($value)){return $value instanceof Traversable;}elseif(is_array($value)){$i=0;foreach($value as $k=>$v){if($k!==$i++){return false;}}return true;}else{return false;}}protected function prepareContextStack($context=null){$stack=new Mustache_Context;$helpers=$this->mustache->getHelpers();if(!$helpers->isEmpty()){$stack->push($helpers);}if(!empty($context)){$stack->push($context);}return $stack;}}class Mustache_Tokenizer{const IN_TEXT=0;const IN_TAG_TYPE=1;const IN_TAG=2;const T_SECTION='#';const T_INVERTED='^';const T_END_SECTION='/';const T_COMMENT='!';const T_PARTIAL='>';const T_PARTIAL_2='<';const T_DELIM_CHANGE='=';const T_ESCAPED='_v';const T_UNESCAPED='{';const T_UNESCAPED_2='&';const T_TEXT='_t';private static $tagTypes=array(self::T_SECTION=>true,self::T_INVERTED=>true,self::T_END_SECTION=>true,self::T_COMMENT=>true,self::T_PARTIAL=>true,self::T_PARTIAL_2=>true,self::T_DELIM_CHANGE=>true,self::T_ESCAPED=>true,self::T_UNESCAPED=>true,self::T_UNESCAPED_2=>true,);private static $interpolatedTags=array(self::T_ESCAPED=>true,self::T_UNESCAPED=>true,self::T_UNESCAPED_2=>true,);const TYPE='type';const NAME='name';const OTAG='otag';const CTAG='ctag';const INDEX='index';const END='end';const INDENT='indent';const NODES='nodes';const VALUE='value';private $state;private $tagType;private $tag;private $buffer;private $tokens;private $seenTag;private $lineStart;private $otag;private $ctag;public function scan($text,$delimiters=null){$this->reset();if($delimiters=trim($delimiters)){list($otag,$ctag)=explode(' ',$delimiters);$this->otag=$otag;$this->ctag=$ctag;}$len=strlen($text);for($i=0;$i<$len;$i++){switch($this->state){case  self::IN_TEXT:if($this->tagChange($this->otag,$text,$i)){$i--;$this->flushBuffer();$this->state=self::IN_TAG_TYPE;}else{if($text[$i]=="\n"){$this->filterLine();}else{$this->buffer.=$text[$i];}}break;case  self::IN_TAG_TYPE:$i+=strlen($this->otag)-1;if(isset(self::$tagTypes[$text[$i+1]])){$tag=$text[$i+1];$this->tagType=$tag;}else{$tag=null;$this->tagType=self::T_ESCAPED;}if($this->tagType===self::T_DELIM_CHANGE){$i=$this->changeDelimiters($text,$i);$this->state=self::IN_TEXT;}else{if($tag!==null){$i++;}$this->state=self::IN_TAG;}$this->seenTag=$i;break;default:if($this->tagChange($this->ctag,$text,$i)){$this->tokens[]=array(self::TYPE=>$this->tagType,self::NAME=>trim($this->buffer),self::OTAG=>$this->otag,self::CTAG=>$this->ctag,self::INDEX=>($this->tagType==self::T_END_SECTION)?$this->seenTag-strlen($this->otag):$i+strlen($this->ctag));$this->buffer='';$i+=strlen($this->ctag)-1;$this->state=self::IN_TEXT;if($this->tagType==self::T_UNESCAPED){if($this->ctag=='}}'){$i++;}else{$lastName=$this->tokens[count($this->tokens)-1][self::NAME];if(substr($lastName,-1)==='}'){$this->tokens[count($this->tokens)-1][self::NAME]=trim(substr($lastName,0,-1));}}}}else{$this->buffer.=$text[$i];}break;}}$this->filterLine(true);return $this->tokens;}private function reset(){$this->state=self::IN_TEXT;$this->tagType=null;$this->tag=null;$this->buffer='';$this->tokens=array();$this->seenTag=false;$this->lineStart=0;$this->otag='{{';$this->ctag='}}';}private function flushBuffer(){if(!empty($this->buffer)){$this->tokens[]=array(self::TYPE=>self::T_TEXT,self::VALUE=>$this->buffer);$this->buffer='';}}private function lineIsWhitespace(){$tokensCount=count($this->tokens);for($j=$this->lineStart;$j<$tokensCount;$j++){$token=$this->tokens[$j];if(isset(self::$tagTypes[$token[self::TYPE]])){if(isset(self::$interpolatedTags[$token[self::TYPE]])){return false;}}elseif($token[self::TYPE]==self::T_TEXT){if(preg_match('/\S/',$token[self::VALUE])){return false;}}}return true;}private function filterLine($noNewLine=false){$this->flushBuffer();if($this->seenTag&&$this->lineIsWhitespace()){$tokensCount=count($this->tokens);for($j=$this->lineStart;$j<$tokensCount;$j++){if($this->tokens[$j][self::TYPE]==self::T_TEXT){if(isset($this->tokens[$j+1])&&$this->tokens[$j+1][self::TYPE]==self::T_PARTIAL){$this->tokens[$j+1][self::INDENT]=$this->tokens[$j][self::VALUE];}$this->tokens[$j]=null;}}}elseif(!$noNewLine){$this->tokens[]=array(self::TYPE=>self::T_TEXT,self::VALUE=>"\n");}$this->seenTag=false;$this->lineStart=count($this->tokens);}private function changeDelimiters($text,$index){$startIndex=strpos($text,'=',$index)+1;$close='='.$this->ctag;$closeIndex=strpos($text,$close,$index);list($otag,$ctag)=explode(' ',trim(substr($text,$startIndex,$closeIndex-$startIndex)));$this->otag=$otag;$this->ctag=$ctag;return $closeIndex+strlen($close)-1;}private function tagChange($tag,$text,$index){return substr($text,$index,strlen($tag))===$tag;}}
?>
